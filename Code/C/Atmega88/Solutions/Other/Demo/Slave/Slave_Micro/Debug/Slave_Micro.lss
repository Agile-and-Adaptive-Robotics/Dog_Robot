
Slave_Micro.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001a  00800100  00000156  000001ea  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000156  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000006  0080011a  0080011a  00000204  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000204  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000234  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000110  00000000  00000000  00000270  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000015a9  00000000  00000000  00000380  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000be0  00000000  00000000  00001929  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000878  00000000  00000000  00002509  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000284  00000000  00000000  00002d84  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000007d1  00000000  00000000  00003008  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000950  00000000  00000000  000037d9  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000d0  00000000  00000000  00004129  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	19 c0       	rjmp	.+50     	; 0x34 <__ctors_end>
   2:	33 c0       	rjmp	.+102    	; 0x6a <__bad_interrupt>
   4:	32 c0       	rjmp	.+100    	; 0x6a <__bad_interrupt>
   6:	31 c0       	rjmp	.+98     	; 0x6a <__bad_interrupt>
   8:	30 c0       	rjmp	.+96     	; 0x6a <__bad_interrupt>
   a:	2f c0       	rjmp	.+94     	; 0x6a <__bad_interrupt>
   c:	2e c0       	rjmp	.+92     	; 0x6a <__bad_interrupt>
   e:	2d c0       	rjmp	.+90     	; 0x6a <__bad_interrupt>
  10:	2c c0       	rjmp	.+88     	; 0x6a <__bad_interrupt>
  12:	2b c0       	rjmp	.+86     	; 0x6a <__bad_interrupt>
  14:	2a c0       	rjmp	.+84     	; 0x6a <__bad_interrupt>
  16:	29 c0       	rjmp	.+82     	; 0x6a <__bad_interrupt>
  18:	28 c0       	rjmp	.+80     	; 0x6a <__bad_interrupt>
  1a:	27 c0       	rjmp	.+78     	; 0x6a <__bad_interrupt>
  1c:	26 c0       	rjmp	.+76     	; 0x6a <__bad_interrupt>
  1e:	25 c0       	rjmp	.+74     	; 0x6a <__bad_interrupt>
  20:	24 c0       	rjmp	.+72     	; 0x6a <__bad_interrupt>
  22:	23 c0       	rjmp	.+70     	; 0x6a <__bad_interrupt>
  24:	22 c0       	rjmp	.+68     	; 0x6a <__bad_interrupt>
  26:	21 c0       	rjmp	.+66     	; 0x6a <__bad_interrupt>
  28:	20 c0       	rjmp	.+64     	; 0x6a <__bad_interrupt>
  2a:	1f c0       	rjmp	.+62     	; 0x6a <__bad_interrupt>
  2c:	1e c0       	rjmp	.+60     	; 0x6a <__bad_interrupt>
  2e:	1d c0       	rjmp	.+58     	; 0x6a <__bad_interrupt>
  30:	1c c0       	rjmp	.+56     	; 0x6a <__bad_interrupt>
  32:	1b c0       	rjmp	.+54     	; 0x6a <__bad_interrupt>

00000034 <__ctors_end>:
  34:	11 24       	eor	r1, r1
  36:	1f be       	out	0x3f, r1	; 63
  38:	cf ef       	ldi	r28, 0xFF	; 255
  3a:	d4 e0       	ldi	r29, 0x04	; 4
  3c:	de bf       	out	0x3e, r29	; 62
  3e:	cd bf       	out	0x3d, r28	; 61

00000040 <__do_copy_data>:
  40:	11 e0       	ldi	r17, 0x01	; 1
  42:	a0 e0       	ldi	r26, 0x00	; 0
  44:	b1 e0       	ldi	r27, 0x01	; 1
  46:	e6 e5       	ldi	r30, 0x56	; 86
  48:	f1 e0       	ldi	r31, 0x01	; 1
  4a:	02 c0       	rjmp	.+4      	; 0x50 <__do_copy_data+0x10>
  4c:	05 90       	lpm	r0, Z+
  4e:	0d 92       	st	X+, r0
  50:	aa 31       	cpi	r26, 0x1A	; 26
  52:	b1 07       	cpc	r27, r17
  54:	d9 f7       	brne	.-10     	; 0x4c <__do_copy_data+0xc>

00000056 <__do_clear_bss>:
  56:	21 e0       	ldi	r18, 0x01	; 1
  58:	aa e1       	ldi	r26, 0x1A	; 26
  5a:	b1 e0       	ldi	r27, 0x01	; 1
  5c:	01 c0       	rjmp	.+2      	; 0x60 <.do_clear_bss_start>

0000005e <.do_clear_bss_loop>:
  5e:	1d 92       	st	X+, r1

00000060 <.do_clear_bss_start>:
  60:	a0 32       	cpi	r26, 0x20	; 32
  62:	b2 07       	cpc	r27, r18
  64:	e1 f7       	brne	.-8      	; 0x5e <.do_clear_bss_loop>
  66:	40 d0       	rcall	.+128    	; 0xe8 <main>
  68:	74 c0       	rjmp	.+232    	; 0x152 <_exit>

0000006a <__bad_interrupt>:
  6a:	ca cf       	rjmp	.-108    	; 0x0 <__vectors>

0000006c <setup_pins>:
	
	// Set which pins contribute to the pin change interrupt.
	PCMSK2 |= ( (1 << PCINT21) |(1 << PCINT22) | (1 << PCINT23) );					// Pins PD5 = PCINT21, Pins PD6 = PCINT22, and PD7 = PCINT23 contribute to the pin change interrupt.
	
	// Enable the pin change interrupts.
	PCICR |= (1 << PCIE2);
  6c:	83 e1       	ldi	r24, 0x13	; 19
  6e:	84 b9       	out	0x04, r24	; 4
  70:	17 b8       	out	0x07, r1	; 7
  72:	8e e3       	ldi	r24, 0x3E	; 62
  74:	8a b9       	out	0x0a, r24	; 10
  76:	28 98       	cbi	0x05, 0	; 5
  78:	29 98       	cbi	0x05, 1	; 5
  7a:	2c 98       	cbi	0x05, 4	; 5
  7c:	5a 98       	cbi	0x0b, 2	; 11
  7e:	5b 98       	cbi	0x0b, 3	; 11
  80:	5c 98       	cbi	0x0b, 4	; 11
  82:	5d 98       	cbi	0x0b, 5	; 11
  84:	08 95       	ret

00000086 <setup_SPI>:
  86:	82 ec       	ldi	r24, 0xC2	; 194
  88:	8c bd       	out	0x2c, r24	; 44
  8a:	8d b5       	in	r24, 0x2d	; 45
  8c:	8e b5       	in	r24, 0x2e	; 46
  8e:	08 95       	ret

00000090 <setup_timer_interrupts>:
  90:	e1 e8       	ldi	r30, 0x81	; 129
  92:	f0 e0       	ldi	r31, 0x00	; 0
  94:	80 81       	ld	r24, Z
  96:	88 60       	ori	r24, 0x08	; 8
  98:	80 83       	st	Z, r24
  9a:	af e6       	ldi	r26, 0x6F	; 111
  9c:	b0 e0       	ldi	r27, 0x00	; 0
  9e:	8c 91       	ld	r24, X
  a0:	82 60       	ori	r24, 0x02	; 2
  a2:	8c 93       	st	X, r24
  a4:	8f e7       	ldi	r24, 0x7F	; 127
  a6:	9e e3       	ldi	r25, 0x3E	; 62
  a8:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__DATA_REGION_ORIGIN__+0x29>
  ac:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__DATA_REGION_ORIGIN__+0x28>
  b0:	80 81       	ld	r24, Z
  b2:	81 60       	ori	r24, 0x01	; 1
  b4:	80 83       	st	Z, r24
  b6:	08 95       	ret

000000b8 <setup_USART>:

// Implement a function to setup USART communication.
void setup_USART( void )
{
	//USART Setup
	UBRR0H = MYUBRR >> 8;
  b8:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__DATA_REGION_ORIGIN__+0x65>
	UBRR0L = MYUBRR;
  bc:	80 e1       	ldi	r24, 0x10	; 16
  be:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__DATA_REGION_ORIGIN__+0x64>
	UCSR0B = (1<<RXEN0)|(1<<TXEN0);
  c2:	88 e1       	ldi	r24, 0x18	; 24
  c4:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
	stdout = &mystdout;
  c8:	80 e0       	ldi	r24, 0x00	; 0
  ca:	91 e0       	ldi	r25, 0x01	; 1
  cc:	90 93 1d 01 	sts	0x011D, r25	; 0x80011d <__data_end+0x3>
  d0:	80 93 1c 01 	sts	0x011C, r24	; 0x80011c <__data_end+0x2>
  d4:	08 95       	ret

000000d6 <setup_micro>:
// Implement a function to setup microcontroller functionality.
void setup_micro( void )
{
	
	//Setup the microcontroller pins.
	setup_pins();
  d6:	ca df       	rcall	.-108    	; 0x6c <setup_pins>

// Implement a function to setup ADC.
void setup_ADC( void )
{
	//Setup the ADC.
	ADCSRA = 0b10000111;	//ADC on, /128 for a 16 MHz clock, interrupt off.		
  d8:	87 e8       	ldi	r24, 0x87	; 135
  da:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
	
	//Setup for ADC.
	setup_ADC();
	
	//Setup SPI communication.
	setup_SPI();
  de:	d3 df       	rcall	.-90     	; 0x86 <setup_SPI>
	
	//Setup timer interrupts.
	setup_timer_interrupts();
  e0:	d7 df       	rcall	.-82     	; 0x90 <setup_timer_interrupts>
	
	//Setup USART communication.
	setup_USART();	
  e2:	ea df       	rcall	.-44     	; 0xb8 <setup_USART>
	
	//Enable global interrupts.
	sei();													// Enable global interrupts
  e4:	78 94       	sei
  e6:	08 95       	ret

000000e8 <main>:
// Implement the main function.
int main( void )
{
	
	// Setup the microcontroller.
	setup_micro(  );
  e8:	f6 df       	rcall	.-20     	; 0xd6 <setup_micro>

	// Set the SPI bytes to send to be all zeros.
	initialize_spi_bytes_to_send( &SPI_manager );
  ea:	8e e0       	ldi	r24, 0x0E	; 14
  ec:	91 e0       	ldi	r25, 0x01	; 1
  ee:	1a d0       	rcall	.+52     	; 0x124 <initialize_spi_bytes_to_send>

	// Toggle a pin to indicate that the microcontroller setup was completed.
	//toggle_pin( &PORTD, 4 );
	tbi( PORTD, 2 );
  f0:	9b b1       	in	r25, 0x0b	; 11
  f2:	84 e0       	ldi	r24, 0x04	; 4
  f4:	89 27       	eor	r24, r25
  f6:	8b b9       	out	0x0b, r24	; 11

	//// Create an empty loop.
	//while( 1 ){  }

	sbi( PORTB, 1 );
  f8:	29 9a       	sbi	0x05, 1	; 5
		
		// Open the valve to add air.
		//PORTB |= (1 << 1);
		//tbi( PORTB, 1 );
		//sbi( PORTB, 1 );
		cbi( PORTB, 1 );
  fa:	29 98       	cbi	0x05, 1	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  fc:	2f ef       	ldi	r18, 0xFF	; 255
  fe:	83 ed       	ldi	r24, 0xD3	; 211
 100:	90 e3       	ldi	r25, 0x30	; 48
 102:	21 50       	subi	r18, 0x01	; 1
 104:	80 40       	sbci	r24, 0x00	; 0
 106:	90 40       	sbci	r25, 0x00	; 0
 108:	e1 f7       	brne	.-8      	; 0x102 <main+0x1a>
 10a:	00 c0       	rjmp	.+0      	; 0x10c <main+0x24>
 10c:	00 00       	nop
		_delay_ms(1000.);
		
		// Close the valve to exhaust air.
		//PORTB &= ~(1 << 1);
		//cbi( PORTB, 1 );
		sbi( PORTB, 1 );
 10e:	29 9a       	sbi	0x05, 1	; 5
 110:	2f ef       	ldi	r18, 0xFF	; 255
 112:	83 ed       	ldi	r24, 0xD3	; 211
 114:	90 e3       	ldi	r25, 0x30	; 48
 116:	21 50       	subi	r18, 0x01	; 1
 118:	80 40       	sbci	r24, 0x00	; 0
 11a:	90 40       	sbci	r25, 0x00	; 0
 11c:	e1 f7       	brne	.-8      	; 0x116 <main+0x2e>
 11e:	00 c0       	rjmp	.+0      	; 0x120 <main+0x38>
 120:	00 00       	nop
 122:	eb cf       	rjmp	.-42     	; 0xfa <main+0x12>

00000124 <initialize_spi_bytes_to_send>:
#include "Slave_Micro_Header.h"


// Implement a function to initialize the SPI bytes to send.
void initialize_spi_bytes_to_send( struct SPI_data_struct * SPI_manager_ptr )
{
 124:	fc 01       	movw	r30, r24
	// Initialize the SPI bytes to send to be all zeros.
	for ( uint8_t k = 0; k < NUM_SPI_BYTES_TO_SEND; ++k )					// Iterate through each of the SPI bytes to send...
	{
		
		// Set each SPI byte to zero.
		SPI_manager_ptr->spi_bytes_to_send[k] = 0;
 126:	14 82       	std	Z+4, r1	; 0x04
 128:	15 82       	std	Z+5, r1	; 0x05
 12a:	16 82       	std	Z+6, r1	; 0x06
 12c:	17 82       	std	Z+7, r1	; 0x07
 12e:	10 86       	std	Z+8, r1	; 0x08
 130:	11 86       	std	Z+9, r1	; 0x09
 132:	08 95       	ret

00000134 <usart_write_uint8>:
}


// Implement a function to write a uint8 to Matlab via USART.
void usart_write_uint8( uint8_t write_value, FILE * stream )
{
 134:	cf 93       	push	r28
 136:	c8 2f       	mov	r28, r24
	
	// UCSRnA = USART Control and Status Register n A (e.g., UCSR0A = USART Control and Status Register 0 A).  Contains information relevant to USART operation, such as whether transmission / reception has been completed.
	// UDREn = USART Data Register Empty (e.g., UDRE0 = USART Data Register Empty 0).  0 = The register is not empty and therefore not ready to be written to, 1 = The register is empty and therefore ready to be written to.
	
	// Determine whether to replace the uint8 we are writing.
	if (write_value == '\n')					// If the write value uint8 represents a new line character...
 138:	8a 30       	cpi	r24, 0x0A	; 10
 13a:	11 f4       	brne	.+4      	; 0x140 <usart_write_uint8+0xc>
	{
		
		// Replace the new line character with a carriage return character.
		usart_write_uint8( '\r', stream );
 13c:	8d e0       	ldi	r24, 0x0D	; 13
 13e:	fa df       	rcall	.-12     	; 0x134 <usart_write_uint8>
		
	}
	
	// Ensure that the USART data register is ready to be written to.
	loop_until_bit_is_set(UCSR0A, UDRE0);
 140:	e0 ec       	ldi	r30, 0xC0	; 192
 142:	f0 e0       	ldi	r31, 0x00	; 0
 144:	80 81       	ld	r24, Z
 146:	85 ff       	sbrs	r24, 5
 148:	fd cf       	rjmp	.-6      	; 0x144 <usart_write_uint8+0x10>
	
	// Write the uint8 to the
	UDR0 = write_value;
 14a:	c0 93 c6 00 	sts	0x00C6, r28	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
	
}
 14e:	cf 91       	pop	r28
 150:	08 95       	ret

00000152 <_exit>:
 152:	f8 94       	cli

00000154 <__stop_program>:
 154:	ff cf       	rjmp	.-2      	; 0x154 <__stop_program>

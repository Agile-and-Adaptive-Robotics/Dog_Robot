classdef link_class
    
    % This class contains properties and methods related to links (links and joints combine to form limbs).
    
    
    %% LINK PROPERTIES
    
    % Define class properties.
    properties
        ID
        name
        parent_joint_ID
        child_joint_ID
        start_point
        end_point
        mass
        len
        width
        Icm
        pcm
        vcm
        wcm
        mesh
        mesh_type
    end
    
    
    %% LINK METHODS SETUP
    
    % Define class methods.
    methods
        
        % Implement the class constructor.
        function self = link_class( ID, name, parent_joint_ID, child_joint_ID, start_point, end_point, len, width, mass, pcm, vcm, wcm, mesh_type, mesh )
            
            % Set the class properties.
            if nargin < 14, self.mesh = []; else, self.mesh = mesh; end
            if nargin < 13, self.mesh_type = ''; else, self.mesh_type = mesh_type; end
            if nargin < 12, self.wcm = []; else, self.wcm = wcm; end
            if nargin < 11, self.vcm = []; else, self.vcm = vcm; end
            if nargin < 10, self.pcm = []; else, self.pcm = pcm; end
            if nargin < 9, self.mass = []; else, self.mass = mass; end
            if nargin < 8, self.width = []; else, self.width = width; end
            if nargin < 7, self.len = []; else, self.len = len; end
            if nargin < 6, self.end_point = []; else, self.end_point = end_point; end
            if nargin < 5, self.start_point = []; else, self.start_point = start_point; end
            if nargin < 4, self.child_joint_ID = []; else, self.child_joint_ID = child_joint_ID; end
            if nargin < 3, self.parent_joint_ID = []; else, self.parent_joint_ID = parent_joint_ID; end
            if nargin < 2, self.name = ''; else, self.name = name; end
            if nargin < 1, self.ID = []; else, self.ID = ID; end
            
            % Generate the 
            
            % Compute the moment of inertia of the link.
            self = self.compute_Icm(  );
            
        end
        
        
        % Implement a function to compute the length of the link.
        function link_length = compute_link_length( self )
            
            % Compute the link length.
            link_length = norm( self.end_point - self.start_point, 2 );
            
        end
        
        
        % Implement a function to set the length of the link.
        function self = set_link_length( self, link_length )
            
            % Determine whether to set or to compute the link length.
            if nargin < 2               % If a link length was not provided...
                
                % Compute the link length.
                self.len = self.compute_link_length(  );
                
            else                        % Otherwise...
                
                % Set the link length to be the provided length.
                self.len = link_length;
                
            end
        end
        
        
        % Implement a function to compute a links mesh assuming that it is a cuboid.
        function Ps = get_cuboid_points( ~, sx, sy, sz, dx, dy, dz, thetax, thetay, thetaz )
            
            % Define default input arguments.
            if nargin < 10, thetaz = 0; end
            if nargin < 9, thetay = 0; end
            if nargin < 8, thetax = 0; end
            if nargin < 7, dz = 0; end
            if nargin < 6, dy = 0; end
            if nargin < 5, dx = 0; end
            if nargin < 4, sz = 1; end
            if nargin < 3, sy = 1; end
            if nargin < 2, sx = 1; end
            
            % Create a scaling matrix.
            S = [ sx 0 0 0; 0 sy 0 0; 0 0 sz 0; 0 0 0 1 ];
            
            % Create a rotation matrix.
            Rx = [ 1 0 0 0; 0 cos(thetax) -sin(thetax) 0; 0 sin(thetax) cos(thetax) 0; 0 0 0 1 ];
            Ry = [ cos(thetay) 0 sin(thetay) 0; 0 1 0 0; -sin(thetay) 0 cos(thetay) 0; 0 0 0 1 ];
            Rz = [ cos(thetaz) sin(thetaz) 0 0; -sin(thetaz) cos(thetaz) 0 0; 0 0 1 0; 0 0 0 1 ];
            R = Rz*Ry*Rx;
            
            % Create a translation matrix.
            T = [ 1 0 0 dx; 0 1 0 dy; 0 0 1 dz; 0 0 0 1 ];
            
            % Define the template cubiod points.
            xs = 0.5*[ -1 -1 -1 -1 -1 1 1 -1 1 1 -1 1 1 -1 1 1 ];
            ys = 0.5*[ -1 1 1 -1 -1 -1 1 1 1 1 1 1 -1 -1 -1 -1 ];
            zs = 0.5*[ -1 -1 1 1 -1 -1 -1 -1 -1 1 1 1 1 1 1 -1 ];
            Ps = [ xs; ys; zs; ones(1, length(xs)) ];
            
            % Transform the cuboid based on the desired properties.
            Ps = T*R*S*Ps;
            
            % Remove the last row that is filled with ones.
            Ps(end, :) = [];
            
        end
        
        
        % Implement a function to set the link mesh.
        function self = generate_mesh( self )
            
            % Determine how to set the link mesh.
            if strcmp( self.mesh_type, 'Cuboid' ) || strcmp( self.mesh_type, 'cuboid' )               % If the mesh type is cuboid...
                
                % Compute the cuboid mesh points.
                self.mesh = self.get_cuboid_points( self.len, self.width, self.width, self.pcm(1), self.pcm(2), self.pcm(3), 0, 0, 0 );
                
            else                                                                            % Otherwise...
                
                % Throw an error.
                error( 'Mesh type %s not recognized.', self.mesh_type )
                
            end
            
        end
        
        
        % Implement a function to compute the moment of inertia of a cuboid link.
        function Icm = compute_cuboid_Icm( ~, m, sx, sy, sz )
            
            % Compute the moment of inertia of the specified cuboid.
            Icm = [ (1/12)*m*(sy^2 + sz^2), 0, 0;
                0, (1/12)*m*(sx^2 + sz^2), 0;
                0, 0, (1/12)*m*(sx^2 + sy^2) ];
            
        end
        
        
        % Implement a function to compute the moment of inertia for the link.
        function self = compute_Icm( self )
            
            % Determine how to compute the moment of inertia of the link.
            if strcmp( self.mesh_type, 'Cuboid' ) || strcmp( self.mesh_type, 'cuboid' )                     % If the link is a cuboid...
                
                % Compute the moment of inertia of the link as a cuboid.
                self.Icm = self.compute_cuboid_Icm( self.mass, self.len, self.width, self.width );
                
            else
                
                % Throw an error.
                error('Mesh type %s not recognized.', self.mesh_type)
                
            end
            
        end
        
        
    end
end

